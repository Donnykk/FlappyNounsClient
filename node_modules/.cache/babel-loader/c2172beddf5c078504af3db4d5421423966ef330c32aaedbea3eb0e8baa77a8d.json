{"ast":null,"code":"import { Interface, Typed } from \"../abi/index.js\";\nimport { isAddressable, resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log } from \"../providers/provider.js\";\nimport { defineProperties, getBigInt, isCallException, isHexString, resolveProperties, isError, makeError, assert, assertArgument } from \"../utils/index.js\";\nimport { ContractEventPayload, ContractUnknownEventPayload, ContractTransactionResponse, EventLog, UndecodedEventLog } from \"./wrappers.js\";\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n  return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n  return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n  return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n  return value && typeof value.sendTransaction === \"function\";\n}\nfunction getResolver(value) {\n  if (value != null) {\n    if (canResolve(value)) {\n      return value;\n    }\n    if (value.provider) {\n      return value.provider;\n    }\n  }\n  return undefined;\n}\nclass PreparedTopicFilter {\n  #filter;\n  fragment;\n  constructor(contract, fragment, args) {\n    defineProperties(this, {\n      fragment\n    });\n    if (fragment.inputs.length < args.length) {\n      throw new Error(\"too many arguments\");\n    }\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(contract.runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    this.#filter = async function () {\n      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n        const arg = args[index];\n        if (arg == null) {\n          return null;\n        }\n        return param.walkAsync(args[index], (type, value) => {\n          if (type === \"address\") {\n            if (Array.isArray(value)) {\n              return Promise.all(value.map(v => resolveAddress(v, resolver)));\n            }\n            return resolveAddress(value, resolver);\n          }\n          return value;\n        });\n      }));\n      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n    }();\n  }\n  getTopicFilter() {\n    return this.#filter;\n  }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n  if (value == null) {\n    return null;\n  }\n  if (typeof value[feature] === \"function\") {\n    return value;\n  }\n  if (value.provider && typeof value.provider[feature] === \"function\") {\n    return value.provider;\n  }\n  return null;\n}\nfunction getProvider(value) {\n  if (value == null) {\n    return null;\n  }\n  return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nexport async function copyOverrides(arg, allowed) {\n  // Make sure the overrides passed in are a valid overrides object\n  const _overrides = Typed.dereference(arg, \"overrides\");\n  assertArgument(typeof _overrides === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n  // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n  const overrides = copyRequest(_overrides);\n  assertArgument(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n  assertArgument(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n  // Resolve any from\n  if (overrides.from) {\n    overrides.from = overrides.from;\n  }\n  return overrides;\n}\n/**\n *  @_ignore:\n */\nexport async function resolveArgs(_runner, inputs, args) {\n  // Recursively descend into args and resolve any addresses\n  const runner = getRunner(_runner, \"resolveName\");\n  const resolver = canResolve(runner) ? runner : null;\n  return await Promise.all(inputs.map((param, index) => {\n    return param.walkAsync(args[index], (type, value) => {\n      value = Typed.dereference(value, type);\n      if (type === \"address\") {\n        return resolveAddress(value, resolver);\n      }\n      return value;\n    });\n  }));\n}\nfunction buildWrappedFallback(contract) {\n  const populateTransaction = async function (overrides) {\n    // If an overrides was passed in, copy it and normalize the values\n    const tx = await copyOverrides(overrides, [\"data\"]);\n    tx.to = await contract.getAddress();\n    if (tx.from) {\n      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));\n    }\n    const iface = contract.interface;\n    const noValue = getBigInt(tx.value || BN_0, \"overrides.value\") === BN_0;\n    const noData = (tx.data || \"0x\") === \"0x\";\n    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n      assertArgument(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n    }\n    assertArgument(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n    // Only allow payable contracts to set non-zero value\n    const payable = iface.receive || iface.fallback && iface.fallback.payable;\n    assertArgument(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n    // Only allow fallback contracts to set non-empty data\n    assertArgument(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n    return tx;\n  };\n  const staticCall = async function (overrides) {\n    const runner = getRunner(contract.runner, \"call\");\n    assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"call\"\n    });\n    const tx = await populateTransaction(overrides);\n    try {\n      return await runner.call(tx);\n    } catch (error) {\n      if (isCallException(error) && error.data) {\n        throw contract.interface.makeError(error.data, tx);\n      }\n      throw error;\n    }\n  };\n  const send = async function (overrides) {\n    const runner = contract.runner;\n    assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const tx = await runner.sendTransaction(await populateTransaction(overrides));\n    const provider = getProvider(contract.runner);\n    // @TODO: the provider can be null; make a custom dummy provider that will throw a\n    // meaningful error\n    return new ContractTransactionResponse(contract.interface, provider, tx);\n  };\n  const estimateGas = async function (overrides) {\n    const runner = getRunner(contract.runner, \"estimateGas\");\n    assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"estimateGas\"\n    });\n    return await runner.estimateGas(await populateTransaction(overrides));\n  };\n  const method = async overrides => {\n    return await send(overrides);\n  };\n  defineProperties(method, {\n    _contract: contract,\n    estimateGas,\n    populateTransaction,\n    send,\n    staticCall\n  });\n  return method;\n}\nfunction buildWrappedMethod(contract, key) {\n  const getFragment = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const fragment = contract.interface.getFunction(key, args);\n    assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\",\n      info: {\n        key,\n        args\n      }\n    });\n    return fragment;\n  };\n  const populateTransaction = async function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const fragment = getFragment(...args);\n    // If an overrides was passed in, copy it and normalize the values\n    let overrides = {};\n    if (fragment.inputs.length + 1 === args.length) {\n      overrides = await copyOverrides(args.pop());\n      if (overrides.from) {\n        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));\n      }\n    }\n    if (fragment.inputs.length !== args.length) {\n      throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n    }\n    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n    return Object.assign({}, overrides, await resolveProperties({\n      to: contract.getAddress(),\n      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n    }));\n  };\n  const staticCall = async function () {\n    const result = await staticCallResult(...arguments);\n    if (result.length === 1) {\n      return result[0];\n    }\n    return result;\n  };\n  const send = async function () {\n    const runner = contract.runner;\n    assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const tx = await runner.sendTransaction(await populateTransaction(...arguments));\n    const provider = getProvider(contract.runner);\n    // @TODO: the provider can be null; make a custom dummy provider that will throw a\n    // meaningful error\n    return new ContractTransactionResponse(contract.interface, provider, tx);\n  };\n  const estimateGas = async function () {\n    const runner = getRunner(contract.runner, \"estimateGas\");\n    assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"estimateGas\"\n    });\n    return await runner.estimateGas(await populateTransaction(...arguments));\n  };\n  const staticCallResult = async function () {\n    const runner = getRunner(contract.runner, \"call\");\n    assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"call\"\n    });\n    const tx = await populateTransaction(...arguments);\n    let result = \"0x\";\n    try {\n      result = await runner.call(tx);\n    } catch (error) {\n      if (isCallException(error) && error.data) {\n        throw contract.interface.makeError(error.data, tx);\n      }\n      throw error;\n    }\n    const fragment = getFragment(...arguments);\n    return contract.interface.decodeFunctionResult(fragment, result);\n  };\n  const method = async function () {\n    const fragment = getFragment(...arguments);\n    if (fragment.constant) {\n      return await staticCall(...arguments);\n    }\n    return await send(...arguments);\n  };\n  defineProperties(method, {\n    name: contract.interface.getFunctionName(key),\n    _contract: contract,\n    _key: key,\n    getFragment,\n    estimateGas,\n    populateTransaction,\n    send,\n    staticCall,\n    staticCallResult\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: () => {\n      const fragment = contract.interface.getFunction(key);\n      assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\",\n        info: {\n          key\n        }\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\nfunction buildWrappedEvent(contract, key) {\n  const getFragment = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    const fragment = contract.interface.getEvent(key, args);\n    assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\",\n      info: {\n        key,\n        args\n      }\n    });\n    return fragment;\n  };\n  const method = function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return new PreparedTopicFilter(contract, getFragment(...args), args);\n  };\n  defineProperties(method, {\n    name: contract.interface.getEventName(key),\n    _contract: contract,\n    _key: key,\n    getFragment\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: () => {\n      const fragment = contract.interface.getEvent(key);\n      assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\",\n        info: {\n          key\n        }\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n  internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n  return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n  return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n  let topics;\n  let fragment = null;\n  // Convert named events to topicHash and get the fragment for\n  // events which need deconstructing.\n  if (Array.isArray(event)) {\n    const topicHashify = function (name) {\n      if (isHexString(name, 32)) {\n        return name;\n      }\n      const fragment = contract.interface.getEvent(name);\n      assertArgument(fragment, \"unknown fragment\", \"name\", name);\n      return fragment.topicHash;\n    };\n    // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n    topics = event.map(e => {\n      if (e == null) {\n        return null;\n      }\n      if (Array.isArray(e)) {\n        return e.map(topicHashify);\n      }\n      return topicHashify(e);\n    });\n  } else if (event === \"*\") {\n    topics = [null];\n  } else if (typeof event === \"string\") {\n    if (isHexString(event, 32)) {\n      // Topic Hash\n      topics = [event];\n    } else {\n      // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n      fragment = contract.interface.getEvent(event);\n      assertArgument(fragment, \"unknown fragment\", \"event\", event);\n      topics = [fragment.topicHash];\n    }\n  } else if (isDeferred(event)) {\n    // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n    topics = await event.getTopicFilter();\n  } else if (\"fragment\" in event) {\n    // ContractEvent; e.g. `contract.filter.Transfer`\n    fragment = event.fragment;\n    topics = [fragment.topicHash];\n  } else {\n    assertArgument(false, \"unknown event name\", \"event\", event);\n  }\n  // Normalize topics and sort TopicSets\n  topics = topics.map(t => {\n    if (t == null) {\n      return null;\n    }\n    if (Array.isArray(t)) {\n      const items = Array.from(new Set(t.map(t => t.toLowerCase())).values());\n      if (items.length === 1) {\n        return items[0];\n      }\n      items.sort();\n      return items;\n    }\n    return t.toLowerCase();\n  });\n  const tag = topics.map(t => {\n    if (t == null) {\n      return \"null\";\n    }\n    if (Array.isArray(t)) {\n      return t.join(\"|\");\n    }\n    return t;\n  }).join(\"&\");\n  return {\n    fragment,\n    tag,\n    topics\n  };\n}\nasync function hasSub(contract, event) {\n  const {\n    subs\n  } = getInternal(contract);\n  return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n  // Make sure our runner can actually subscribe to events\n  const provider = getProvider(contract.runner);\n  assert(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n    operation\n  });\n  const {\n    fragment,\n    tag,\n    topics\n  } = await getSubInfo(contract, event);\n  const {\n    addr,\n    subs\n  } = getInternal(contract);\n  let sub = subs.get(tag);\n  if (!sub) {\n    const address = addr ? addr : contract;\n    const filter = {\n      address,\n      topics\n    };\n    const listener = log => {\n      let foundFragment = fragment;\n      if (foundFragment == null) {\n        try {\n          foundFragment = contract.interface.getEvent(log.topics[0]);\n        } catch (error) {}\n      }\n      // If fragment is null, we do not deconstruct the args to emit\n      if (foundFragment) {\n        const _foundFragment = foundFragment;\n        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n        emit(contract, event, args, listener => {\n          return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n        });\n      } else {\n        emit(contract, event, [], listener => {\n          return new ContractUnknownEventPayload(contract, listener, event, log);\n        });\n      }\n    };\n    let starting = [];\n    const start = () => {\n      if (starting.length) {\n        return;\n      }\n      starting.push(provider.on(filter, listener));\n    };\n    const stop = async () => {\n      if (starting.length == 0) {\n        return;\n      }\n      let started = starting;\n      starting = [];\n      await Promise.all(started);\n      provider.off(filter, listener);\n    };\n    sub = {\n      tag,\n      listeners: [],\n      start,\n      stop\n    };\n    subs.set(tag, sub);\n  }\n  return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n  await lastEmit;\n  const sub = await hasSub(contract, event);\n  if (!sub) {\n    return false;\n  }\n  const count = sub.listeners.length;\n  sub.listeners = sub.listeners.filter(_ref => {\n    let {\n      listener,\n      once\n    } = _ref;\n    const passArgs = Array.from(args);\n    if (payloadFunc) {\n      passArgs.push(payloadFunc(once ? null : listener));\n    }\n    try {\n      listener.call(contract, ...passArgs);\n    } catch (error) {}\n    return !once;\n  });\n  if (sub.listeners.length === 0) {\n    sub.stop();\n    getInternal(contract).subs.delete(sub.tag);\n  }\n  return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n  try {\n    await lastEmit;\n  } catch (error) {}\n  const resultPromise = _emit(contract, event, args, payloadFunc);\n  lastEmit = resultPromise;\n  return await resultPromise;\n}\nconst passProperties = [\"then\"];\nexport class BaseContract {\n  /**\n   *  The target to connect to.\n   *\n   *  This can be an address, ENS name or any [[Addressable]], such as\n   *  another contract. To get the resovled address, use the ``getAddress``\n   *  method.\n   */\n  target;\n  /**\n   *  The contract Interface.\n   */\n  interface;\n  /**\n   *  The connected runner. This is generally a [[Provider]] or a\n   *  [[Signer]], which dictates what operations are supported.\n   *\n   *  For example, a **Contract** connected to a [[Provider]] may\n   *  only execute read-only operations.\n   */\n  runner;\n  /**\n   *  All the Events available on this contract.\n   */\n  filters;\n  /**\n   *  @_ignore:\n   */\n  [internal];\n  /**\n   *  The fallback or receive function if any.\n   */\n  fallback;\n  /**\n   *  Creates a new contract connected to %%target%% with the %%abi%% and\n   *  optionally connected to a %%runner%% to perform operations on behalf\n   *  of.\n   */\n  constructor(target, abi, runner, _deployTx) {\n    assertArgument(typeof target === \"string\" || isAddressable(target), \"invalid value for Contract target\", \"target\", target);\n    if (runner == null) {\n      runner = null;\n    }\n    const iface = Interface.from(abi);\n    defineProperties(this, {\n      target,\n      runner,\n      interface: iface\n    });\n    Object.defineProperty(this, internal, {\n      value: {}\n    });\n    let addrPromise;\n    let addr = null;\n    let deployTx = null;\n    if (_deployTx) {\n      const provider = getProvider(runner);\n      // @TODO: the provider can be null; make a custom dummy provider that will throw a\n      // meaningful error\n      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);\n    }\n    let subs = new Map();\n    // Resolve the target as the address\n    if (typeof target === \"string\") {\n      if (isHexString(target)) {\n        addr = target;\n        addrPromise = Promise.resolve(target);\n      } else {\n        const resolver = getRunner(runner, \"resolveName\");\n        if (!canResolve(resolver)) {\n          throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n          });\n        }\n        addrPromise = resolver.resolveName(target).then(addr => {\n          if (addr == null) {\n            throw makeError(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n              value: target\n            });\n          }\n          getInternal(this).addr = addr;\n          return addr;\n        });\n      }\n    } else {\n      addrPromise = target.getAddress().then(addr => {\n        if (addr == null) {\n          throw new Error(\"TODO\");\n        }\n        getInternal(this).addr = addr;\n        return addr;\n      });\n    }\n    // Set our private values\n    setInternal(this, {\n      addrPromise,\n      addr,\n      deployTx,\n      subs\n    });\n    // Add the event filters\n    const filters = new Proxy({}, {\n      get: (target, prop, receiver) => {\n        // Pass important checks (like `then` for Promise) through\n        if (typeof prop === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n          return Reflect.get(target, prop, receiver);\n        }\n        try {\n          return this.getEvent(prop);\n        } catch (error) {\n          if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n            throw error;\n          }\n        }\n        return undefined;\n      },\n      has: (target, prop) => {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n      }\n    });\n    defineProperties(this, {\n      filters\n    });\n    defineProperties(this, {\n      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n    });\n    // Return a Proxy that will respond to functions\n    return new Proxy(this, {\n      get: (target, prop, receiver) => {\n        if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n          return Reflect.get(target, prop, receiver);\n        }\n        // Undefined properties should return undefined\n        try {\n          return target.getFunction(prop);\n        } catch (error) {\n          if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n            throw error;\n          }\n        }\n        return undefined;\n      },\n      has: (target, prop) => {\n        if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return target.interface.hasFunction(prop);\n      }\n    });\n  }\n  /**\n   *  Return a new Contract instance with the same target and ABI, but\n   *  a different %%runner%%.\n   */\n  connect(runner) {\n    return new BaseContract(this.target, this.interface, runner);\n  }\n  /**\n   *  Return a new Contract instance with the same ABI and runner, but\n   *  a different %%target%%.\n   */\n  attach(target) {\n    return new BaseContract(target, this.interface, this.runner);\n  }\n  /**\n   *  Return the resolved address of this Contract.\n   */\n  async getAddress() {\n    return await getInternal(this).addrPromise;\n  }\n  /**\n   *  Return the deployed bytecode or null if no bytecode is found.\n   */\n  async getDeployedCode() {\n    const provider = getProvider(this.runner);\n    assert(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"getDeployedCode\"\n    });\n    const code = await provider.getCode(await this.getAddress());\n    if (code === \"0x\") {\n      return null;\n    }\n    return code;\n  }\n  /**\n   *  Resolve to this Contract once the bytecode has been deployed, or\n   *  resolve immediately if already deployed.\n   */\n  async waitForDeployment() {\n    // We have the deployement transaction; just use that (throws if deployement fails)\n    const deployTx = this.deploymentTransaction();\n    if (deployTx) {\n      await deployTx.wait();\n      return this;\n    }\n    // Check for code\n    const code = await this.getDeployedCode();\n    if (code != null) {\n      return this;\n    }\n    // Make sure we can subscribe to a provider event\n    const provider = getProvider(this.runner);\n    assert(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"waitForDeployment\"\n    });\n    return new Promise((resolve, reject) => {\n      const checkCode = async () => {\n        try {\n          const code = await this.getDeployedCode();\n          if (code != null) {\n            return resolve(this);\n          }\n          provider.once(\"block\", checkCode);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      checkCode();\n    });\n  }\n  /**\n   *  Return the transaction used to deploy this contract.\n   *\n   *  This is only available if this instance was returned from a\n   *  [[ContractFactory]].\n   */\n  deploymentTransaction() {\n    return getInternal(this).deployTx;\n  }\n  /**\n   *  Return the function for a given name. This is useful when a contract\n   *  method name conflicts with a JavaScript name such as ``prototype`` or\n   *  when using a Contract programatically.\n   */\n  getFunction(key) {\n    if (typeof key !== \"string\") {\n      key = key.format();\n    }\n    const func = buildWrappedMethod(this, key);\n    return func;\n  }\n  /**\n   *  Return the event for a given name. This is useful when a contract\n   *  event name conflicts with a JavaScript name such as ``prototype`` or\n   *  when using a Contract programatically.\n   */\n  getEvent(key) {\n    if (typeof key !== \"string\") {\n      key = key.format();\n    }\n    return buildWrappedEvent(this, key);\n  }\n  /**\n   *  @_ignore:\n   */\n  async queryTransaction(hash) {\n    throw new Error(\"@TODO\");\n  }\n  /*\n  // @TODO: this is a non-backwards compatible change, but will be added\n  //        in v7 and in a potential SmartContract class in an upcoming\n  //        v6 release\n  async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n      const provider = getProvider(this.runner);\n      assert(provider, \"contract runner does not have a provider\",\n          \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n       const receipt = await provider.getTransactionReceipt(hash);\n      if (receipt == null) { return null; }\n       return new ContractTransactionReceipt(this.interface, provider, receipt);\n  }\n  */\n  /**\n   *  Provide historic access to event data for %%event%% in the range\n   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n   *  inclusive.\n   */\n  async queryFilter(event, fromBlock, toBlock) {\n    if (fromBlock == null) {\n      fromBlock = 0;\n    }\n    if (toBlock == null) {\n      toBlock = \"latest\";\n    }\n    const {\n      addr,\n      addrPromise\n    } = getInternal(this);\n    const address = addr ? addr : await addrPromise;\n    const {\n      fragment,\n      topics\n    } = await getSubInfo(this, event);\n    const filter = {\n      address,\n      topics,\n      fromBlock,\n      toBlock\n    };\n    const provider = getProvider(this.runner);\n    assert(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"queryFilter\"\n    });\n    return (await provider.getLogs(filter)).map(log => {\n      let foundFragment = fragment;\n      if (foundFragment == null) {\n        try {\n          foundFragment = this.interface.getEvent(log.topics[0]);\n        } catch (error) {}\n      }\n      if (foundFragment) {\n        try {\n          return new EventLog(log, this.interface, foundFragment);\n        } catch (error) {\n          return new UndecodedEventLog(log, error);\n        }\n      }\n      return new Log(log, provider);\n    });\n  }\n  /**\n   *  Add an event %%listener%% for the %%event%%.\n   */\n  async on(event, listener) {\n    const sub = await getSub(this, \"on\", event);\n    sub.listeners.push({\n      listener,\n      once: false\n    });\n    sub.start();\n    return this;\n  }\n  /**\n   *  Add an event %%listener%% for the %%event%%, but remove the listener\n   *  after it is fired once.\n   */\n  async once(event, listener) {\n    const sub = await getSub(this, \"once\", event);\n    sub.listeners.push({\n      listener,\n      once: true\n    });\n    sub.start();\n    return this;\n  }\n  /**\n   *  Emit an %%event%% calling all listeners with %%args%%.\n   *\n   *  Resolves to ``true`` if any listeners were called.\n   */\n  async emit(event) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n    return await emit(this, event, args, null);\n  }\n  /**\n   *  Resolves to the number of listeners of %%event%% or the total number\n   *  of listeners if unspecified.\n   */\n  async listenerCount(event) {\n    if (event) {\n      const sub = await hasSub(this, event);\n      if (!sub) {\n        return 0;\n      }\n      return sub.listeners.length;\n    }\n    const {\n      subs\n    } = getInternal(this);\n    let total = 0;\n    for (const {\n      listeners\n    } of subs.values()) {\n      total += listeners.length;\n    }\n    return total;\n  }\n  /**\n   *  Resolves to the listeners subscribed to %%event%% or all listeners\n   *  if unspecified.\n   */\n  async listeners(event) {\n    if (event) {\n      const sub = await hasSub(this, event);\n      if (!sub) {\n        return [];\n      }\n      return sub.listeners.map(_ref2 => {\n        let {\n          listener\n        } = _ref2;\n        return listener;\n      });\n    }\n    const {\n      subs\n    } = getInternal(this);\n    let result = [];\n    for (const {\n      listeners\n    } of subs.values()) {\n      result = result.concat(listeners.map(_ref3 => {\n        let {\n          listener\n        } = _ref3;\n        return listener;\n      }));\n    }\n    return result;\n  }\n  /**\n   *  Remove the %%listener%% from the listeners for %%event%% or remove\n   *  all listeners if unspecified.\n   */\n  async off(event, listener) {\n    const sub = await hasSub(this, event);\n    if (!sub) {\n      return this;\n    }\n    if (listener) {\n      const index = sub.listeners.map(_ref4 => {\n        let {\n          listener\n        } = _ref4;\n        return listener;\n      }).indexOf(listener);\n      if (index >= 0) {\n        sub.listeners.splice(index, 1);\n      }\n    }\n    if (listener == null || sub.listeners.length === 0) {\n      sub.stop();\n      getInternal(this).subs.delete(sub.tag);\n    }\n    return this;\n  }\n  /**\n   *  Remove all the listeners for %%event%% or remove all listeners if\n   *  unspecified.\n   */\n  async removeAllListeners(event) {\n    if (event) {\n      const sub = await hasSub(this, event);\n      if (!sub) {\n        return this;\n      }\n      sub.stop();\n      getInternal(this).subs.delete(sub.tag);\n    } else {\n      const {\n        subs\n      } = getInternal(this);\n      for (const {\n        tag,\n        stop\n      } of subs.values()) {\n        stop();\n        subs.delete(tag);\n      }\n    }\n    return this;\n  }\n  /**\n   *  Alias for [on].\n   */\n  async addListener(event, listener) {\n    return await this.on(event, listener);\n  }\n  /**\n   *  Alias for [off].\n   */\n  async removeListener(event, listener) {\n    return await this.off(event, listener);\n  }\n  /**\n   *  Create a new Class for the %%abi%%.\n   */\n  static buildClass(abi) {\n    class CustomContract extends BaseContract {\n      constructor(address) {\n        let runner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        super(address, abi, runner);\n      }\n    }\n    return CustomContract;\n  }\n  /**\n   *  Create a new BaseContract with a specified Interface.\n   */\n  static from(target, abi, runner) {\n    if (runner == null) {\n      runner = null;\n    }\n    const contract = new this(target, abi, runner);\n    return contract;\n  }\n}\nfunction _ContractBase() {\n  return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nexport class Contract extends _ContractBase() {}","map":{"version":3,"names":["Interface","Typed","isAddressable","resolveAddress","copyRequest","Log","defineProperties","getBigInt","isCallException","isHexString","resolveProperties","isError","makeError","assert","assertArgument","ContractEventPayload","ContractUnknownEventPayload","ContractTransactionResponse","EventLog","UndecodedEventLog","BN_0","BigInt","canCall","value","call","canEstimate","estimateGas","canResolve","resolveName","canSend","sendTransaction","getResolver","provider","undefined","PreparedTopicFilter","filter","fragment","constructor","contract","args","inputs","length","Error","runner","getRunner","resolver","resolvedArgs","Promise","all","map","param","index","arg","walkAsync","type","Array","isArray","v","interface","encodeFilterTopics","getTopicFilter","feature","getProvider","copyOverrides","allowed","_overrides","dereference","overrides","to","indexOf","data","from","resolveArgs","_runner","buildWrappedFallback","populateTransaction","tx","getAddress","iface","noValue","noData","fallback","payable","receive","staticCall","operation","error","send","method","_contract","buildWrappedMethod","key","getFragment","getFunction","info","pop","Object","assign","encodeFunctionData","result","staticCallResult","decodeFunctionResult","constant","name","getFunctionName","_key","defineProperty","configurable","enumerable","get","buildWrappedEvent","getEvent","getEventName","internal","Symbol","for","internalValues","WeakMap","setInternal","values","set","getInternal","isDeferred","getSubInfo","event","topics","topicHashify","topicHash","e","t","items","Set","toLowerCase","sort","tag","join","hasSub","subs","getSub","addr","sub","address","listener","log","foundFragment","_foundFragment","decodeEventLog","emit","starting","start","push","on","stop","started","off","listeners","lastEmit","resolve","_emit","payloadFunc","count","once","passArgs","delete","resultPromise","passProperties","BaseContract","target","filters","abi","_deployTx","addrPromise","deployTx","Map","then","Proxy","prop","receiver","Reflect","argument","has","hasEvent","String","hasFunction","connect","attach","getDeployedCode","code","getCode","waitForDeployment","deploymentTransaction","wait","reject","checkCode","format","func","queryTransaction","hash","queryFilter","fromBlock","toBlock","getLogs","listenerCount","total","concat","splice","removeAllListeners","addListener","removeListener","buildClass","CustomContract","_ContractBase","Contract"],"sources":["/Users/donny/Desktop/FlappyNounsClient/node_modules/ethers/lib.esm/contract/contract.js"],"sourcesContent":["import { Interface, Typed } from \"../abi/index.js\";\nimport { isAddressable, resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log } from \"../providers/provider.js\";\nimport { defineProperties, getBigInt, isCallException, isHexString, resolveProperties, isError, makeError, assert, assertArgument } from \"../utils/index.js\";\nimport { ContractEventPayload, ContractUnknownEventPayload, ContractTransactionResponse, EventLog, UndecodedEventLog } from \"./wrappers.js\";\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return (value && typeof (value.call) === \"function\");\n}\nfunction canEstimate(value) {\n    return (value && typeof (value.estimateGas) === \"function\");\n}\nfunction canResolve(value) {\n    return (value && typeof (value.resolveName) === \"function\");\n}\nfunction canSend(value) {\n    return (value && typeof (value.sendTransaction) === \"function\");\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    fragment;\n    constructor(contract, fragment, args) {\n        defineProperties(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = (async function () {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v) => resolveAddress(v, resolver)));\n                        }\n                        return resolveAddress(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value[feature]) === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof (value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nexport async function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = Typed.dereference(arg, \"overrides\");\n    assertArgument(typeof (_overrides) === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = copyRequest(_overrides);\n    assertArgument(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    assertArgument(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */\nexport async function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = Typed.dereference(value, type);\n            if (type === \"address\") {\n                return resolveAddress(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function (overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = (await copyOverrides(overrides, [\"data\"]));\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await resolveAddress(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = (getBigInt((tx.value || BN_0), \"overrides.value\") === BN_0);\n        const noData = ((tx.data || \"0x\") === \"0x\");\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            assertArgument(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        assertArgument(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        assertArgument(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        assertArgument(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function (overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        }\n        catch (error) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function (overrides) {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides) => {\n        return await send(overrides);\n    };\n    defineProperties(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function (...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await resolveProperties({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function (...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function (...args) {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function (...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        }\n        catch (error) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    defineProperties(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const method = function (...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    defineProperties(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return (value && typeof (value) === \"object\" && (\"getTopicFilter\" in value) &&\n        (typeof (value.getTopicFilter) === \"function\") && value.fragment);\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function (name) {\n            if (isHexString(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    }\n    else if (event === \"*\") {\n        topics = [null];\n    }\n    else if (typeof (event) === \"string\") {\n        if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [event];\n        }\n        else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [fragment.topicHash];\n        }\n    }\n    else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    }\n    else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [fragment.topicHash];\n    }\n    else {\n        assertArgument(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t) => {\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return { fragment, tag, topics };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    assert(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", { operation });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = (addr ? addr : contract);\n        const filter = { address, topics };\n        const listener = (log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener) => {\n                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            }\n            else {\n                emit(contract, event, [], (listener) => {\n                    return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = () => {\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async () => {\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = { tag, listeners: [], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        }\n        catch (error) { }\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return (count > 0);\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    }\n    catch (error) { }\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\"then\"];\nexport class BaseContract {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    target;\n    /**\n     *  The contract Interface.\n     */\n    interface;\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    runner;\n    /**\n     *  All the Events available on this contract.\n     */\n    filters;\n    /**\n     *  @_ignore:\n     */\n    [internal];\n    /**\n     *  The fallback or receive function if any.\n     */\n    fallback;\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */\n    constructor(target, abi, runner, _deployTx) {\n        assertArgument(typeof (target) === \"string\" || isAddressable(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = Interface.from(abi);\n        defineProperties(this, { target, runner, interface: iface });\n        Object.defineProperty(this, internal, { value: {} });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof (target) === \"string\") {\n            if (isHexString(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            }\n            else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) {\n                        throw makeError(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        }\n        else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (typeof (prop) === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                }\n                catch (error) {\n                    if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        defineProperties(this, { filters });\n        defineProperties(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                }\n                catch (error) {\n                    if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */\n    connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n    attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */\n    async getAddress() { return await getInternal(this).addrPromise; }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */\n    async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        assert(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n    async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        assert(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                }\n                catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n    deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getFunction(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getEvent(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */\n    async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n    async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr : (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            if (foundFragment) {\n                try {\n                    return new EventLog(log, this.interface, foundFragment);\n                }\n                catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return new Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n    async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n    async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n    async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n    async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n    async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n    async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n    async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */\n    async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n    static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    ;\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nexport class Contract extends _ContractBase() {\n}\n//# sourceMappingURL=contract.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}