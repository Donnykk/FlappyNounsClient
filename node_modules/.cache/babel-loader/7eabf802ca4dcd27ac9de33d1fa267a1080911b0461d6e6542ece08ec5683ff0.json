{"ast":null,"code":"import { assert, isHexString } from \"../utils/index.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if (isHexString(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber {\n  #provider;\n  #poller;\n  #interval;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  /**\n   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#poller = null;\n    this.#interval = 4000;\n    this.#blockNumber = -2;\n  }\n  /**\n   *  The polling interval.\n   */\n  get pollingInterval() {\n    return this.#interval;\n  }\n  set pollingInterval(value) {\n    this.#interval = value;\n  }\n  async #poll() {\n    try {\n      const blockNumber = await this.#provider.getBlockNumber();\n      // Bootstrap poll to setup our initial block number\n      if (this.#blockNumber === -2) {\n        this.#blockNumber = blockNumber;\n        return;\n      }\n      // @TODO: Put a cap on the maximum number of events per loop?\n      if (blockNumber !== this.#blockNumber) {\n        for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n          // We have been stopped\n          if (this.#poller == null) {\n            return;\n          }\n          await this.#provider.emit(\"block\", b);\n        }\n        this.#blockNumber = blockNumber;\n      }\n    } catch (error) {\n      // @TODO: Minor bump, add an \"error\" event to let subscribers\n      //        know things went awry.\n      //console.log(error);\n    }\n    // We have been stopped\n    if (this.#poller == null) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n  }\n  start() {\n    if (this.#poller) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    this.#poll();\n  }\n  stop() {\n    if (!this.#poller) {\n      return;\n    }\n    this.#provider._clearTimeout(this.#poller);\n    this.#poller = null;\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber {\n  #provider;\n  #poll;\n  #running;\n  /**\n   *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#running = false;\n    this.#poll = blockNumber => {\n      this._poll(blockNumber, this.#provider);\n    };\n  }\n  /**\n   *  Called on every new block.\n   */\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    this.#poll(-2);\n    this.#provider.on(\"block\", this.#poll);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poll);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n  #tag;\n  #lastBlock;\n  constructor(provider, tag) {\n    super(provider);\n    this.#tag = tag;\n    this.#lastBlock = -2;\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      this.#lastBlock = -2;\n    }\n    super.pause(dropWhilePaused);\n  }\n  async _poll(blockNumber, provider) {\n    const block = await provider.getBlock(this.#tag);\n    if (block == null) {\n      return;\n    }\n    if (this.#lastBlock === -2) {\n      this.#lastBlock = block.number;\n    } else if (block.number > this.#lastBlock) {\n      provider.emit(this.#tag, block.number);\n      this.#lastBlock = block.number;\n    }\n  }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n  #filter;\n  constructor(provider, filter) {\n    super(provider);\n    this.#filter = copy(filter);\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(this.#filter);\n  }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n  #hash;\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%hash%%.\n   */\n  constructor(provider, hash) {\n    super(provider);\n    this.#hash = hash;\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(this.#hash);\n    if (tx) {\n      provider.emit(this.#hash, tx);\n    }\n  }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber {\n  #provider;\n  #filter;\n  #poller;\n  #running;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    this.#provider = provider;\n    this.#filter = copy(filter);\n    this.#poller = this.#poll.bind(this);\n    this.#running = false;\n    this.#blockNumber = -2;\n  }\n  async #poll(blockNumber) {\n    // The initial block hasn't been determined yet\n    if (this.#blockNumber === -2) {\n      return;\n    }\n    const filter = copy(this.#filter);\n    filter.fromBlock = this.#blockNumber + 1;\n    filter.toBlock = blockNumber;\n    const logs = await this.#provider.getLogs(filter);\n    // No logs could just mean the node has not indexed them yet,\n    // so we keep a sliding window of 60 blocks to keep scanning\n    if (logs.length === 0) {\n      if (this.#blockNumber < blockNumber - 60) {\n        this.#blockNumber = blockNumber - 60;\n      }\n      return;\n    }\n    for (const log of logs) {\n      this.#provider.emit(this.#filter, log);\n      // Only advance the block number when logs were found to\n      // account for networks (like BNB and Polygon) which may\n      // sacrifice event consistency for block event speed\n      this.#blockNumber = log.blockNumber;\n    }\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    if (this.#blockNumber === -2) {\n      this.#provider.getBlockNumber().then(blockNumber => {\n        this.#blockNumber = blockNumber;\n      });\n    }\n    this.#provider.on(\"block\", this.#poller);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}","map":{"version":3,"names":["assert","isHexString","copy","obj","JSON","parse","stringify","getPollingSubscriber","provider","event","PollingBlockSubscriber","PollingTransactionSubscriber","operation","info","poller","interval","blockNumber","constructor","pollingInterval","value","poll","getBlockNumber","b","emit","error","_setTimeout","bind","start","stop","_clearTimeout","pause","dropWhilePaused","resume","OnBlockSubscriber","running","_poll","Error","on","off","PollingBlockTagSubscriber","tag","lastBlock","block","getBlock","number","PollingOrphanSubscriber","filter","console","log","hash","tx","getTransactionReceipt","PollingEventSubscriber","fromBlock","toBlock","logs","getLogs","length","then"],"sources":["/Users/donny/Desktop/FlappyNounsClient/node_modules/ethers/lib.esm/providers/subscriber-polling.js"],"sourcesContent":["import { assert, isHexString } from \"../utils/index.js\";\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if (isHexString(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval() { return this.#interval; }\n    set pollingInterval(value) { this.#interval = value; }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        }\n        catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber) => {\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) { this.stop(); }\n    resume() { this.start(); }\n}\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n    #tag;\n    #lastBlock;\n    constructor(provider, tag) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#lastBlock = -2;\n        }\n        super.pause(dropWhilePaused);\n    }\n    async _poll(blockNumber, provider) {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) {\n            return;\n        }\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        }\n        else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider, hash) {\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n//# sourceMappingURL=subscriber-polling.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}