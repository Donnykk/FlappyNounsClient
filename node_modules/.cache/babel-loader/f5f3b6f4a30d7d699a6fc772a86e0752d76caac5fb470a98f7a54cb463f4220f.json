{"ast":null,"code":"import { Interface } from \"../abi/index.js\";\nimport { getCreateAddress } from \"../address/index.js\";\nimport { concat, defineProperties, getBytes, hexlify, assert, assertArgument } from \"../utils/index.js\";\nimport { BaseContract, copyOverrides, resolveArgs } from \"./contract.js\";\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */\nexport class ContractFactory {\n  /**\n   *  The Contract Interface.\n   */\n  interface;\n  /**\n   *  The Contract deployment bytecode. Often called the initcode.\n   */\n  bytecode;\n  /**\n   *  The ContractRunner to deploy the Contract as.\n   */\n  runner;\n  /**\n   *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n   *  optionally connected to %%runner%%.\n   *\n   *  The %%bytecode%% may be the ``bytecode`` property within the\n   *  standard Solidity JSON output.\n   */\n  constructor(abi, bytecode, runner) {\n    const iface = Interface.from(abi);\n    // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n    if (bytecode instanceof Uint8Array) {\n      bytecode = hexlify(getBytes(bytecode));\n    } else {\n      if (typeof bytecode === \"object\") {\n        bytecode = bytecode.object;\n      }\n      if (!bytecode.startsWith(\"0x\")) {\n        bytecode = \"0x\" + bytecode;\n      }\n      bytecode = hexlify(getBytes(bytecode));\n    }\n    defineProperties(this, {\n      bytecode,\n      interface: iface,\n      runner: runner || null\n    });\n  }\n  attach(target) {\n    return new BaseContract(target, this.interface, this.runner);\n  }\n  /**\n   *  Resolves to the transaction to deploy the contract, passing %%args%%\n   *  into the constructor.\n   */\n  async getDeployTransaction() {\n    let overrides = {};\n    const fragment = this.interface.deploy;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (fragment.inputs.length + 1 === args.length) {\n      overrides = await copyOverrides(args.pop());\n    }\n    if (fragment.inputs.length !== args.length) {\n      throw new Error(\"incorrect number of arguments to constructor\");\n    }\n    const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);\n    const data = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);\n    return Object.assign({}, overrides, {\n      data\n    });\n  }\n  /**\n   *  Resolves to the Contract deployed by passing %%args%% into the\n   *  constructor.\n   *\n   *  This will resolve to the Contract before it has been deployed to the\n   *  network, so the [[BaseContract-waitForDeployment]] should be used before\n   *  sending any transactions to it.\n   */\n  async deploy() {\n    const tx = await this.getDeployTransaction(...arguments);\n    assert(this.runner && typeof this.runner.sendTransaction === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const sentTx = await this.runner.sendTransaction(tx);\n    const address = getCreateAddress(sentTx);\n    return new BaseContract(address, this.interface, this.runner, sentTx);\n  }\n  /**\n   *  Return a new **ContractFactory** with the same ABI and bytecode,\n   *  but connected to %%runner%%.\n   */\n  connect(runner) {\n    return new ContractFactory(this.interface, this.bytecode, runner);\n  }\n  /**\n   *  Create a new **ContractFactory** from the standard Solidity JSON output.\n   */\n  static fromSolidity(output, runner) {\n    assertArgument(output != null, \"bad compiler output\", \"output\", output);\n    if (typeof output === \"string\") {\n      output = JSON.parse(output);\n    }\n    const abi = output.abi;\n    let bytecode = \"\";\n    if (output.bytecode) {\n      bytecode = output.bytecode;\n    } else if (output.evm && output.evm.bytecode) {\n      bytecode = output.evm.bytecode;\n    }\n    return new this(abi, bytecode, runner);\n  }\n}","map":{"version":3,"names":["Interface","getCreateAddress","concat","defineProperties","getBytes","hexlify","assert","assertArgument","BaseContract","copyOverrides","resolveArgs","ContractFactory","interface","bytecode","runner","constructor","abi","iface","from","Uint8Array","object","startsWith","attach","target","getDeployTransaction","overrides","fragment","deploy","args","inputs","length","pop","Error","resolvedArgs","data","encodeDeploy","Object","assign","tx","sendTransaction","operation","sentTx","address","connect","fromSolidity","output","JSON","parse","evm"],"sources":["/Users/donny/Desktop/FlappyNounsClient/node_modules/ethers/lib.esm/contract/factory.js"],"sourcesContent":["import { Interface } from \"../abi/index.js\";\nimport { getCreateAddress } from \"../address/index.js\";\nimport { concat, defineProperties, getBytes, hexlify, assert, assertArgument } from \"../utils/index.js\";\nimport { BaseContract, copyOverrides, resolveArgs } from \"./contract.js\";\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */\nexport class ContractFactory {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The Contract deployment bytecode. Often called the initcode.\n     */\n    bytecode;\n    /**\n     *  The ContractRunner to deploy the Contract as.\n     */\n    runner;\n    /**\n     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n     *  optionally connected to %%runner%%.\n     *\n     *  The %%bytecode%% may be the ``bytecode`` property within the\n     *  standard Solidity JSON output.\n     */\n    constructor(abi, bytecode, runner) {\n        const iface = Interface.from(abi);\n        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n        if (bytecode instanceof Uint8Array) {\n            bytecode = hexlify(getBytes(bytecode));\n        }\n        else {\n            if (typeof (bytecode) === \"object\") {\n                bytecode = bytecode.object;\n            }\n            if (!bytecode.startsWith(\"0x\")) {\n                bytecode = \"0x\" + bytecode;\n            }\n            bytecode = hexlify(getBytes(bytecode));\n        }\n        defineProperties(this, {\n            bytecode, interface: iface, runner: (runner || null)\n        });\n    }\n    attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Resolves to the transaction to deploy the contract, passing %%args%%\n     *  into the constructor.\n     */\n    async getDeployTransaction(...args) {\n        let overrides = {};\n        const fragment = this.interface.deploy;\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"incorrect number of arguments to constructor\");\n        }\n        const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);\n        const data = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);\n        return Object.assign({}, overrides, { data });\n    }\n    /**\n     *  Resolves to the Contract deployed by passing %%args%% into the\n     *  constructor.\n     *\n     *  This will resolve to the Contract before it has been deployed to the\n     *  network, so the [[BaseContract-waitForDeployment]] should be used before\n     *  sending any transactions to it.\n     */\n    async deploy(...args) {\n        const tx = await this.getDeployTransaction(...args);\n        assert(this.runner && typeof (this.runner.sendTransaction) === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const sentTx = await this.runner.sendTransaction(tx);\n        const address = getCreateAddress(sentTx);\n        return new BaseContract(address, this.interface, this.runner, sentTx);\n    }\n    /**\n     *  Return a new **ContractFactory** with the same ABI and bytecode,\n     *  but connected to %%runner%%.\n     */\n    connect(runner) {\n        return new ContractFactory(this.interface, this.bytecode, runner);\n    }\n    /**\n     *  Create a new **ContractFactory** from the standard Solidity JSON output.\n     */\n    static fromSolidity(output, runner) {\n        assertArgument(output != null, \"bad compiler output\", \"output\", output);\n        if (typeof (output) === \"string\") {\n            output = JSON.parse(output);\n        }\n        const abi = output.abi;\n        let bytecode = \"\";\n        if (output.bytecode) {\n            bytecode = output.bytecode;\n        }\n        else if (output.evm && output.evm.bytecode) {\n            bytecode = output.evm.bytecode;\n        }\n        return new this(abi, bytecode, runner);\n    }\n}\n//# sourceMappingURL=factory.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}