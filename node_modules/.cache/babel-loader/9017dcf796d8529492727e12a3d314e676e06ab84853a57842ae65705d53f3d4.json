{"ast":null,"code":"//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport { recoverAddress } from \"../transaction/index.js\";\nimport { concat, defineProperties, getBigInt, getBytes, hexlify, isHexString, mask, toBeHex, toQuantity, toTwos, zeroPadValue, assertArgument } from \"../utils/index.js\";\nimport { id } from \"./id.js\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n  const bytes = getBytes(value);\n  const padOffset = bytes.length % 32;\n  if (padOffset) {\n    return concat([bytes, padding.slice(padOffset)]);\n  }\n  return hexlify(bytes);\n}\nconst hexTrue = toBeHex(BN_1, 32);\nconst hexFalse = toBeHex(BN_0, 32);\nconst domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nconst domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\nfunction checkString(key) {\n  return function (value) {\n    assertArgument(typeof value === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n    return value;\n  };\n}\nconst domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function (_value) {\n    const value = getBigInt(_value, \"domain.chainId\");\n    assertArgument(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n    if (Number.isSafeInteger(value)) {\n      return Number(value);\n    }\n    return toQuantity(value);\n  },\n  verifyingContract: function (value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n    assertArgument(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n  },\n  salt: function (value) {\n    const bytes = getBytes(value, \"domain.salt\");\n    assertArgument(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n    return hexlify(bytes);\n  }\n};\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    const match = type.match(/^(u?)int(\\d+)$/);\n    if (match) {\n      const signed = match[1] === \"\";\n      const width = parseInt(match[2]);\n      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), \"invalid numeric width\", \"type\", type);\n      const boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);\n      const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n      return function (_value) {\n        const value = getBigInt(_value, \"value\");\n        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n        return toBeHex(signed ? toTwos(value, 256) : value, 32);\n      };\n    }\n  }\n  // bytesXX\n  {\n    const match = type.match(/^bytes(\\d+)$/);\n    if (match) {\n      const width = parseInt(match[1]);\n      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n      return function (value) {\n        const bytes = getBytes(value);\n        assertArgument(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n        return hexPadRight(value);\n      };\n    }\n  }\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return zeroPadValue(getAddress(value), 32);\n      };\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n  return null;\n}\nfunction encodeType(name, fields) {\n  return `${name}(${fields.map(_ref => {\n    let {\n      name,\n      type\n    } = _ref;\n    return type + \" \" + name;\n  }).join(\",\")})`;\n}\n// foo[][3] => { base: \"foo\", index: \"[][3]\", array: {\n//     base: \"foo\", prefix: \"foo[]\", count: 3 } }\nfunction splitArray(type) {\n  const match = type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);\n  if (match) {\n    return {\n      base: match[1],\n      index: match[2] + match[4],\n      array: {\n        base: match[1],\n        prefix: match[1] + match[2],\n        count: match[5] ? parseInt(match[5]) : -1\n      }\n    };\n  }\n  return {\n    base: type\n  };\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nexport class TypedDataEncoder {\n  /**\n   *  The primary type for the structured [[types]].\n   *\n   *  This is derived automatically from the [[types]], since no\n   *  recursion is possible, once the DAG for the types is consturcted\n   *  internally, the primary type must be the only remaining type with\n   *  no parent nodes.\n   */\n  primaryType;\n  #types;\n  /**\n   *  The types.\n   */\n  get types() {\n    return JSON.parse(this.#types);\n  }\n  #fullTypes;\n  #encoderCache;\n  /**\n   *  Create a new **TypedDataEncoder** for %%types%%.\n   *\n   *  This performs all necessary checking that types are valid and\n   *  do not violate the [[link-eip-712]] structural constraints as\n   *  well as computes the [[primaryType]].\n   */\n  constructor(_types) {\n    this.#fullTypes = new Map();\n    this.#encoderCache = new Map();\n    // Link struct types to their direct child structs\n    const links = new Map();\n    // Link structs to structs which contain them as a child\n    const parents = new Map();\n    // Link all subtypes within a given struct\n    const subtypes = new Map();\n    const types = {};\n    Object.keys(_types).forEach(type => {\n      types[type] = _types[type].map(_ref2 => {\n        let {\n          name,\n          type\n        } = _ref2;\n        // Normalize the base type (unless name conflict)\n        let {\n          base,\n          index\n        } = splitArray(type);\n        if (base === \"int\" && !_types[\"int\"]) {\n          base = \"int256\";\n        }\n        if (base === \"uint\" && !_types[\"uint\"]) {\n          base = \"uint256\";\n        }\n        return {\n          name,\n          type: base + (index || \"\")\n        };\n      });\n      links.set(type, new Set());\n      parents.set(type, []);\n      subtypes.set(type, new Set());\n    });\n    this.#types = JSON.stringify(types);\n    for (const name in types) {\n      const uniqueNames = new Set();\n      for (const field of types[name]) {\n        // Check each field has a unique name\n        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", _types);\n        uniqueNames.add(field.name);\n        // Get the base type (drop any array specifiers)\n        const baseType = splitArray(field.type).base;\n        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", _types);\n        // Is this a base encoding type?\n        const encoder = getBaseEncoder(baseType);\n        if (encoder) {\n          continue;\n        }\n        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", _types);\n        // Add linkage\n        parents.get(baseType).push(name);\n        links.get(name).add(baseType);\n      }\n    }\n    // Deduce the primary type\n    const primaryTypes = Array.from(parents.keys()).filter(n => parents.get(n).length === 0);\n    assertArgument(primaryTypes.length !== 0, \"missing primary type\", \"types\", _types);\n    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(\", \")}`, \"types\", _types);\n    defineProperties(this, {\n      primaryType: primaryTypes[0]\n    });\n    // Check for circular type references\n    function checkCircular(type, found) {\n      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", _types);\n      found.add(type);\n      for (const child of links.get(type)) {\n        if (!parents.has(child)) {\n          continue;\n        }\n        // Recursively check children\n        checkCircular(child, found);\n        // Mark all ancestors as having this decendant\n        for (const subtype of found) {\n          subtypes.get(subtype).add(child);\n        }\n      }\n      found.delete(type);\n    }\n    checkCircular(this.primaryType, new Set());\n    // Compute each fully describe type\n    for (const [name, set] of subtypes) {\n      const st = Array.from(set);\n      st.sort();\n      this.#fullTypes.set(name, encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(\"\"));\n    }\n  }\n  /**\n   *  Returnthe encoder for the specific %%type%%.\n   */\n  getEncoder(type) {\n    let encoder = this.#encoderCache.get(type);\n    if (!encoder) {\n      encoder = this.#getEncoder(type);\n      this.#encoderCache.set(type, encoder);\n    }\n    return encoder;\n  }\n  #getEncoder(type) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n      if (encoder) {\n        return encoder;\n      }\n    }\n    // Array\n    const array = splitArray(type).array;\n    if (array) {\n      const subtype = array.prefix;\n      const subEncoder = this.getEncoder(subtype);\n      return value => {\n        assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n        let result = value.map(subEncoder);\n        if (this.#fullTypes.has(subtype)) {\n          result = result.map(keccak256);\n        }\n        return keccak256(concat(result));\n      };\n    }\n    // Struct\n    const fields = this.types[type];\n    if (fields) {\n      const encodedType = id(this.#fullTypes.get(type));\n      return value => {\n        const values = fields.map(_ref3 => {\n          let {\n            name,\n            type\n          } = _ref3;\n          const result = this.getEncoder(type)(value[name]);\n          if (this.#fullTypes.has(type)) {\n            return keccak256(result);\n          }\n          return result;\n        });\n        values.unshift(encodedType);\n        return concat(values);\n      };\n    }\n    assertArgument(false, `unknown type: ${type}`, \"type\", type);\n  }\n  /**\n   *  Return the full type for %%name%%.\n   */\n  encodeType(name) {\n    const result = this.#fullTypes.get(name);\n    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n    return result;\n  }\n  /**\n   *  Return the encoded %%value%% for the %%type%%.\n   */\n  encodeData(type, value) {\n    return this.getEncoder(type)(value);\n  }\n  /**\n   *  Returns the hash of %%value%% for the type of %%name%%.\n   */\n  hashStruct(name, value) {\n    return keccak256(this.encodeData(name, value));\n  }\n  /**\n   *  Return the fulled encoded %%value%% for the [[types]].\n   */\n  encode(value) {\n    return this.encodeData(this.primaryType, value);\n  }\n  /**\n   *  Return the hash of the fully encoded %%value%% for the [[types]].\n   */\n  hash(value) {\n    return this.hashStruct(this.primaryType, value);\n  }\n  /**\n   *  @_ignore:\n   */\n  _visit(type, value, callback) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n      if (encoder) {\n        return callback(type, value);\n      }\n    }\n    // Array\n    const array = splitArray(type).array;\n    if (array) {\n      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n      return value.map(v => this._visit(array.prefix, v, callback));\n    }\n    // Struct\n    const fields = this.types[type];\n    if (fields) {\n      return fields.reduce((accum, _ref4) => {\n        let {\n          name,\n          type\n        } = _ref4;\n        accum[name] = this._visit(type, value[name], callback);\n        return accum;\n      }, {});\n    }\n    assertArgument(false, `unknown type: ${type}`, \"type\", type);\n  }\n  /**\n   *  Call %%calback%% for each value in %%value%%, passing the type and\n   *  component within %%value%%.\n   *\n   *  This is useful for replacing addresses or other transformation that\n   *  may be desired on each component, based on its type.\n   */\n  visit(value, callback) {\n    return this._visit(this.primaryType, value, callback);\n  }\n  /**\n   *  Create a new **TypedDataEncoder** for %%types%%.\n   */\n  static from(types) {\n    return new TypedDataEncoder(types);\n  }\n  /**\n   *  Return the primary type for %%types%%.\n   */\n  static getPrimaryType(types) {\n    return TypedDataEncoder.from(types).primaryType;\n  }\n  /**\n   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n   */\n  static hashStruct(name, types, value) {\n    return TypedDataEncoder.from(types).hashStruct(name, value);\n  }\n  /**\n   *  Return the domain hash for %%domain%%.\n   */\n  static hashDomain(domain) {\n    const domainFields = [];\n    for (const name in domain) {\n      if (domain[name] == null) {\n        continue;\n      }\n      const type = domainFieldTypes[name];\n      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n      domainFields.push({\n        name,\n        type\n      });\n    }\n    domainFields.sort((a, b) => {\n      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n    });\n    return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n      EIP712Domain: domainFields\n    }, domain);\n  }\n  /**\n   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n   */\n  static encode(domain, types, value) {\n    return concat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n  }\n  /**\n   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n   */\n  static hash(domain, types, value) {\n    return keccak256(TypedDataEncoder.encode(domain, types, value));\n  }\n  // Replaces all address types with ENS names with their looked up address\n  /**\n   * Resolves to the value from resolving all addresses in %%value%% for\n   * %%types%% and the %%domain%%.\n   */\n  static async resolveNames(domain, types, value, resolveName) {\n    // Make a copy to isolate it from the object passed in\n    domain = Object.assign({}, domain);\n    // Allow passing null to ignore value\n    for (const key in domain) {\n      if (domain[key] == null) {\n        delete domain[key];\n      }\n    }\n    // Look up all ENS names\n    const ensCache = {};\n    // Do we need to look up the domain's verifyingContract?\n    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n      ensCache[domain.verifyingContract] = \"0x\";\n    }\n    // We are going to use the encoder to visit all the base values\n    const encoder = TypedDataEncoder.from(types);\n    // Get a list of all the addresses\n    encoder.visit(value, (type, value) => {\n      if (type === \"address\" && !isHexString(value, 20)) {\n        ensCache[value] = \"0x\";\n      }\n      return value;\n    });\n    // Lookup each name\n    for (const name in ensCache) {\n      ensCache[name] = await resolveName(name);\n    }\n    // Replace the domain verifyingContract if needed\n    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n      domain.verifyingContract = ensCache[domain.verifyingContract];\n    }\n    // Replace all ENS names with their address\n    value = encoder.visit(value, (type, value) => {\n      if (type === \"address\" && ensCache[value]) {\n        return ensCache[value];\n      }\n      return value;\n    });\n    return {\n      domain,\n      value\n    };\n  }\n  /**\n   *  Returns the JSON-encoded payload expected by nodes which implement\n   *  the JSON-RPC [[link-eip-712]] method.\n   */\n  static getPayload(domain, types, value) {\n    // Validate the domain fields\n    TypedDataEncoder.hashDomain(domain);\n    // Derive the EIP712Domain Struct reference type\n    const domainValues = {};\n    const domainTypes = [];\n    domainFieldNames.forEach(name => {\n      const value = domain[name];\n      if (value == null) {\n        return;\n      }\n      domainValues[name] = domainChecks[name](value);\n      domainTypes.push({\n        name,\n        type: domainFieldTypes[name]\n      });\n    });\n    const encoder = TypedDataEncoder.from(types);\n    // Get the normalized types\n    types = encoder.types;\n    const typesWithDomain = Object.assign({}, types);\n    assertArgument(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n    typesWithDomain.EIP712Domain = domainTypes;\n    // Validate the data structures and types\n    encoder.encode(value);\n    return {\n      types: typesWithDomain,\n      domain: domainValues,\n      primaryType: encoder.primaryType,\n      message: encoder.visit(value, (type, value) => {\n        // bytes\n        if (type.match(/^bytes(\\d*)/)) {\n          return hexlify(getBytes(value));\n        }\n        // uint or int\n        if (type.match(/^u?int/)) {\n          return getBigInt(value).toString();\n        }\n        switch (type) {\n          case \"address\":\n            return value.toLowerCase();\n          case \"bool\":\n            return !!value;\n          case \"string\":\n            assertArgument(typeof value === \"string\", \"invalid string\", \"value\", value);\n            return value;\n        }\n        assertArgument(false, \"unsupported type\", \"type\", type);\n      })\n    };\n  }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nexport function verifyTypedData(domain, types, value, signature) {\n  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}","map":{"version":3,"names":["getAddress","keccak256","recoverAddress","concat","defineProperties","getBigInt","getBytes","hexlify","isHexString","mask","toBeHex","toQuantity","toTwos","zeroPadValue","assertArgument","id","padding","Uint8Array","fill","BN__1","BigInt","BN_0","BN_1","BN_MAX_UINT256","hexPadRight","value","bytes","padOffset","length","slice","hexTrue","hexFalse","domainFieldTypes","name","version","chainId","verifyingContract","salt","domainFieldNames","checkString","key","JSON","stringify","domainChecks","_value","Number","isSafeInteger","toLowerCase","error","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","boundsLower","encodeType","fields","map","join","splitArray","base","index","array","prefix","count","TypedDataEncoder","primaryType","types","parse","fullTypes","encoderCache","constructor","_types","Map","links","parents","subtypes","Object","keys","forEach","set","Set","uniqueNames","field","has","add","baseType","encoder","get","push","primaryTypes","Array","from","filter","n","t","checkCircular","found","child","subtype","delete","st","sort","getEncoder","subEncoder","result","encodedType","values","unshift","encodeData","hashStruct","encode","hash","_visit","callback","v","reduce","accum","visit","getPrimaryType","hashDomain","domain","domainFields","a","b","indexOf","EIP712Domain","resolveNames","resolveName","assign","ensCache","getPayload","domainValues","domainTypes","typesWithDomain","message","toString","verifyTypedData","signature"],"sources":["/Users/donny/Desktop/FlappyNounsClient/node_modules/ethers/lib.esm/hash/typed-data.js"],"sourcesContent":["//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport { recoverAddress } from \"../transaction/index.js\";\nimport { concat, defineProperties, getBigInt, getBytes, hexlify, isHexString, mask, toBeHex, toQuantity, toTwos, zeroPadValue, assertArgument } from \"../utils/index.js\";\nimport { id } from \"./id.js\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = getBytes(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return concat([bytes, padding.slice(padOffset)]);\n    }\n    return hexlify(bytes);\n}\nconst hexTrue = toBeHex(BN_1, 32);\nconst hexFalse = toBeHex(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        assertArgument(typeof (value) === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (_value) {\n        const value = getBigInt(_value, \"domain.chainId\");\n        assertArgument(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return toQuantity(value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return getAddress(value).toLowerCase();\n        }\n        catch (error) { }\n        assertArgument(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        const bytes = getBytes(value, \"domain.salt\");\n        assertArgument(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return hexlify(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d+)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2]);\n            assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = mask(BN_MAX_UINT256, signed ? (width - 1) : width);\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1) : BN_0;\n            return function (_value) {\n                const value = getBigInt(_value, \"value\");\n                assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return toBeHex(signed ? toTwos(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            assertArgument(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function (value) {\n                const bytes = getBytes(value);\n                assertArgument(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return zeroPadValue(getAddress(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return keccak256(value);\n        };\n        case \"string\": return function (value) {\n            return id(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\n// foo[][3] => { base: \"foo\", index: \"[][3]\", array: {\n//     base: \"foo\", prefix: \"foo[]\", count: 3 } }\nfunction splitArray(type) {\n    const match = type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n        return {\n            base: match[1],\n            index: (match[2] + match[4]),\n            array: {\n                base: match[1],\n                prefix: (match[1] + match[2]),\n                count: (match[5] ? parseInt(match[5]) : -1),\n            }\n        };\n    }\n    return { base: type };\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nexport class TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only remaining type with\n     *  no parent nodes.\n     */\n    primaryType;\n    #types;\n    /**\n     *  The types.\n     */\n    get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */\n    constructor(_types) {\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        const types = {};\n        Object.keys(_types).forEach((type) => {\n            types[type] = _types[type].map(({ name, type }) => {\n                // Normalize the base type (unless name conflict)\n                let { base, index } = splitArray(type);\n                if (base === \"int\" && !_types[\"int\"]) {\n                    base = \"int256\";\n                }\n                if (base === \"uint\" && !_types[\"uint\"]) {\n                    base = \"uint256\";\n                }\n                return { name, type: (base + (index || \"\")) };\n            });\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        this.#types = JSON.stringify(types);\n        for (const name in types) {\n            const uniqueNames = new Set();\n            for (const field of types[name]) {\n                // Check each field has a unique name\n                assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", _types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = splitArray(field.type).base;\n                assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n) => (parents.get(n).length === 0));\n        assertArgument(primaryTypes.length !== 0, \"missing primary type\", \"types\", _types);\n        assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", _types);\n        defineProperties(this, { primaryType: primaryTypes[0] });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", _types);\n            found.add(type);\n            for (const child of links.get(type)) {\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found) {\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes) {\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */\n    getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            const subtype = array.prefix;\n            const subEncoder = this.getEncoder(subtype);\n            return (value) => {\n                assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(keccak256);\n                }\n                return keccak256(concat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this.#fullTypes.get(type));\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return keccak256(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return concat(values);\n            };\n        }\n        assertArgument(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */\n    encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        assertArgument(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */\n    hashStruct(name, value) {\n        return keccak256(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n            return value.map((v) => this._visit(array.prefix, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        assertArgument(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static encode(domain, types, value) {\n        return concat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static hash(domain, types, value) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */\n    static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for (const key in domain) {\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value) => {\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return { domain, value };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        // Get the normalized types\n        types = encoder.types;\n        const typesWithDomain = Object.assign({}, types);\n        assertArgument(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(getBytes(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return getBigInt(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        assertArgument(typeof (value) === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                assertArgument(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nexport function verifyTypedData(domain, types, value, signature) {\n    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}\n//# sourceMappingURL=typed-data.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}