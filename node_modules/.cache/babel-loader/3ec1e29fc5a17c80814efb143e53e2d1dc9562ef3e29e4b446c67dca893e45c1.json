{"ast":null,"code":"import { isError } from \"../utils/index.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber {\n  #provider;\n  #filterIdPromise;\n  #poller;\n  #running;\n  #network;\n  #hault;\n  /**\n   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n   *  and [[_emitResults]] to setup the subscription and provide the event\n   *  to the %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#filterIdPromise = null;\n    this.#poller = this.#poll.bind(this);\n    this.#running = false;\n    this.#network = null;\n    this.#hault = false;\n  }\n  /**\n   *  Sub-classes **must** override this to begin the subscription.\n   */\n  _subscribe(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle the events.\n   */\n  _emitResults(provider, result) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle recovery on errors.\n   */\n  _recover(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  async #poll(blockNumber) {\n    try {\n      // Subscribe if necessary\n      if (this.#filterIdPromise == null) {\n        this.#filterIdPromise = this._subscribe(this.#provider);\n      }\n      // Get the Filter ID\n      let filterId = null;\n      try {\n        filterId = await this.#filterIdPromise;\n      } catch (error) {\n        if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n          throw error;\n        }\n      }\n      // The backend does not support Filter ID; downgrade to\n      // polling\n      if (filterId == null) {\n        this.#filterIdPromise = null;\n        this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n        return;\n      }\n      const network = await this.#provider.getNetwork();\n      if (!this.#network) {\n        this.#network = network;\n      }\n      if (this.#network.chainId !== network.chainId) {\n        throw new Error(\"chaid changed\");\n      }\n      if (this.#hault) {\n        return;\n      }\n      const result = await this.#provider.send(\"eth_getFilterChanges\", [filterId]);\n      await this._emitResults(this.#provider, result);\n    } catch (error) {\n      console.log(\"@TODO\", error);\n    }\n    this.#provider.once(\"block\", this.#poller);\n  }\n  #teardown() {\n    const filterIdPromise = this.#filterIdPromise;\n    if (filterIdPromise) {\n      this.#filterIdPromise = null;\n      filterIdPromise.then(filterId => {\n        if (this.#provider.destroyed) {\n          return;\n        }\n        this.#provider.send(\"eth_uninstallFilter\", [filterId]);\n      });\n    }\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    this.#poll(-2);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#hault = true;\n    this.#teardown();\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      this.#teardown();\n    }\n    this.#provider.off(\"block\", this.#poller);\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n  #event;\n  /**\n   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n   *  listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    super(provider);\n    this.#event = copy(filter);\n  }\n  _recover(provider) {\n    return new PollingEventSubscriber(provider, this.#event);\n  }\n  async _subscribe(provider) {\n    const filterId = await provider.send(\"eth_newFilter\", [this.#event]);\n    return filterId;\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(this.#event, provider._wrapLog(result, provider._network));\n    }\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n  async _subscribe(provider) {\n    return await provider.send(\"eth_newPendingTransactionFilter\", []);\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(\"pending\", result);\n    }\n  }\n}","map":{"version":3,"names":["isError","PollingEventSubscriber","copy","obj","JSON","parse","stringify","FilterIdSubscriber","provider","filterIdPromise","poller","running","network","hault","constructor","poll","bind","_subscribe","Error","_emitResults","result","_recover","blockNumber","filterId","error","operation","_recoverSubscriber","getNetwork","chainId","send","console","log","once","teardown","then","destroyed","start","stop","off","pause","dropWhilePaused","resume","FilterIdEventSubscriber","event","filter","results","emit","_wrapLog","_network","FilterIdPendingSubscriber"],"sources":["/Users/donny/Desktop/FlappyNounsClient/node_modules/ethers/lib.esm/providers/subscriber-filterid.js"],"sourcesContent":["import { isError } from \"../utils/index.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */\n    _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */\n    _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */\n    _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            }\n            catch (error) {\n                if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [filterId]);\n            await this._emitResults(this.#provider, result);\n        }\n        catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId) => {\n                if (this.#provider.destroyed) {\n                    return;\n                }\n                this.#provider.send(\"eth_uninstallFilter\", [filterId]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() { this.start(); }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [this.#event]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(\"pending\", result);\n        }\n    }\n}\n//# sourceMappingURL=subscriber-filterid.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}